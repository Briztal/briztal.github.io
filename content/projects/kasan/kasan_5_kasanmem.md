---
title: "KASAN memory management."
summary: "How KASAN manages memory."
series: ["KASAN"]
series_order: 5
categories: ["KASAN"]
#externalUrl: ""
showSummary: true
date: 2023-09-27
showTableOfContents : true
draft: false
---

Now that we know how the kernel manages memory from a high level point of view, let's elaborate on how the KASAN will fit in this system.

# Metadata

The kasan will have to track the status of each byte of memory in the system.

For this, it will need metadata, that it will store in dedicated memory : each byte of memory managed by the memory system will have attributes, that will describe : 
- if the byte is accessible (as defined in `Regions manager` section) ?
- who can access the byte, either user, allocator or both ? 
- is the byte writeable ?
- is the byte initialized ?

This can be achieved by storing 4 bits of attributes per byte of memory.

# Attributes location

The attributes must be located somewhere in memory. To place them, we will use the same strategy as the Regions allocator.

When registering a memory regions in the regions manager, before the region manager allocates all its metadata, the kasan will split the region in two parts : 
- kernel-accessible memory : this part will be forwarded to the region manager, that will divide it in two, pages, and pages metadata.
- kasan attributes : this part will contain 4 bits of attributes for each byte of memory in the kernel-accessible section.

# Attributes lifecycle

The attributes are the base information that the kasan uses to verify a memory access.
A memory access of N bytes starting at A will cause the kasan to fetch the attributes for the address range [A, A + N[, and verify that they allow the access to occur. If so, the kasan will let the access happen. Otherwise, it will trigger an error.

Here are some accesses that should cause an error to occur : 
- reading from an uninitialized byte.
- writing to a non-writeable byte.
- user accessing a byte not accessible to the user.
- allocator accessing a byte not accessible to the allocator.
- access to a nonn accessible byte.

The following diagram describes the lifecycles of attributes, and the various events (accesses) that can occur, so as the errors generated by the kasan checker if any.

# CPU state

To make our attributes model work, we need an additional per-cpu variable that will report whether the said CPU is running allocator code or user code.

This will be used as a base to verify the accesses : 
- a CPU running in user mode accessing a memory block accessible to allocator only will trigger a kasan error (use after free)
- a CPU running in allocator mode accessing a memory block accessible to user only will trigger a kasan error (use after alloc)

# Tuning the allocators

The following diagram relies on the accuracy of the kasan attributes.

Those attributes are not only modified by a direct access like the 'initialized' field.

In particular, any allocation or free in both the Regions manager or the secondary allocators must be reflected in the attributes.

This required the said memory managers to be modified, so that : 
- when the region manager allocates pages, all the related bytes go from 'not accessible' to 'accessible to allocator only'.
- when the region manager allocates pages, all the related bytes go from 'accessible to allocato only'.
- when the secondary allocators allocates memory to the user, all the related bytes go from 'accessible to allocator only' to 'accessible to user only'.
- when the secondary allocators frees memory, all the related bytes go from 'accessible to uswer only' to 'accessible to allocator only'.

When those operations are executed, we must verify that the related bytes are actually on the expected state.

The allocators must also be updated to report their entry / exit in the cpu state.

# Corner cases

The rules stated in the two previous sections are true in the general case.
The FSM described is a high level representation of the reality, but there are some corner cases that make the actual implementation look less like an actual FSM.

The main corner case here is that allocators themselves (the actual allocator structs), so as CPU states, and some part of the kernel main blocks must be accessible both in allocator and user state.

That causes us to need a specific attribute state "accessible to anyone" and dedicated KASAN entrypoints to report that a specified  memory block falls in this category.

I will not provide a detailed explanation on how to actually handle attributes, as it is very implementation-specific.

Another corner case that we have to handle is the state of global variables.

As much as we would like to avoid them, global variables are a necessary evil. Take the memory system data structure for example : it must be initialized during the early stages of boot, when we have not yet registered any memory region, thus, when dynamic allocation is not available. In any case, memory allocation goes through it, so we litteraly can't have it dynamically allocated.

There are a few cases like this one, where we theoretically could avoid using globals, but where there is no real benefit of doing so.

Our kernel executable will have the two regular '.data' and '.bss' sections in which globals / static variables are located.

Those variables are initialized as part of the very early bootstrap sequence, by copying the content of the initializer of .data (likely located in flash) directly in .data, and by zeroing-out the content of .bss.

Those sections must be considered initialized by the kasan, as they indeed _are_ initilized during very early boot.

Though, those sections are located in RAM, and will ultimately be included in a particular memory region.

This will add two tasks to the memory management system when registering a memory region : 
- the regions manager will have to tag all pages in these sections as not allocatable, as those pages are implicitly allocated to the kernel.
- the kasan will have to report any byte in such section as accessible by anyone, and initialized, as opposed to other bytes whose initial state is accessible by no one.
