<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Memory Managers : Introduction. &#183;</title><meta name=title content="Memory Managers : Introduction. &#183; "><meta name=description content="General considerations on memory and memory managers."><link rel=canonical href=briztal.github.io/projects/memory_management/mm_0_into/><link type=text/css rel=stylesheet href=/briztal.github.io/css/main.bundle.min.29653ed199b7a749016920bb9715d240156e67049c90f12ffede5bb7f952606ecd8b0dd0c3f01d75af648960eddb25a879915d6e24858a75d11d9eed0607d9c6.css integrity="sha512-KWU+0Zm3p0kBaSC7lxXSQBVuZwSckPEv/t5bt/lSYG7Niw3Qw/Adda9kiWDt2yWoeZFdbiSFinXRHZ7tBgfZxg=="><script type=text/javascript src=/briztal.github.io/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
<script defer type=text/javascript id=script-bundle src=/briztal.github.io/js/main.bundle.min.5155d528b5217d2be660e88e103a0553710d2c94c85e3221100642905f3e6cbbb67b3760a44ab4f36703f12fbfe1d6f5b4545c3ae3a3f34784d919904ab7f1d7.js integrity="sha512-UVXVKLUhfSvmYOiOEDoFU3ENLJTIXjIhEAZCkF8+bLu2ezdgpEq082cD8S+/4db1tFRcOuOj80eE2RmQSrfx1w==" data-copy=Copy data-copied=Copied></script>
<script src=/briztal.github.io/lib/zoom/zoom.min.f592a181a15d2a5b042daa7f746c3721acf9063f8b6acd175d989129865a37d400ae0e85b640f9ad42cd98d1f8ad30931718cf8811abdcc5fcb264400d1a2b0c.js integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="></script>
<link rel=apple-touch-icon sizes=180x180 href=/briztal.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/briztal.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/briztal.github.io/favicon-16x16.png><link rel=manifest href=/briztal.github.io/site.webmanifest><meta property="og:title" content="Memory Managers : Introduction."><meta property="og:description" content="General considerations on memory and memory managers."><meta property="og:type" content="article"><meta property="og:url" content="briztal.github.io/projects/memory_management/mm_0_into/"><meta property="article:section" content="projects"><meta property="article:published_time" content="2021-09-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-17T00:00:00+00:00"><meta property="og:see_also" content="briztal.github.io/projects/memory_management/mm_1/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memory Managers : Introduction."><meta name=twitter:description content="General considerations on memory and memory managers."><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Personal Projects","name":"Memory Managers : Introduction.","headline":"Memory Managers : Introduction.","abstract":"General considerations on memory and memory managers.","inLanguage":"en","url":"briztal.github.io\/projects\/memory_management\/mm_0_into\/","author":{"@type":"Person","name":""},"copyrightYear":"2021","dateCreated":"2021-09-17T00:00:00\u002b00:00","datePublished":"2021-09-17T00:00:00\u002b00:00","dateModified":"2021-09-17T00:00:00\u002b00:00","mainEntityOfPage":"true","wordCount":"3152"}]</script><script src=/briztal.github.io/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>
<link type=text/css rel=stylesheet href=/briztal.github.io/lib/katex/katex.min.7e7e35e3ef02b7b437449a44ca3fac62ec1ed39cb8312b680a00fe8ac60badc95b063b694636b8440856f7f5e8c2cc9e6b0efb581179b2656c7e1e97558c7096.css integrity="sha512-fn414+8Ct7Q3RJpEyj+sYuwe05y4MStoCgD+isYLrclbBjtpRja4RAhW9/Xowsyeaw77WBF5smVsfh6XVYxwlg=="><script defer src=/briztal.github.io/lib/katex/katex.min.cadd45c1af1f44bdaf196dc9b104f1daeb29043f0dc59155ffe22847510a04390a0b7a859400d420a626204f7fc5ddb07c19311de1c66b25e19c2559d3e126a8.js integrity="sha512-yt1Fwa8fRL2vGW3JsQTx2uspBD8NxZFV/+IoR1EKBDkKC3qFlADUIKYmIE9/xd2wfBkxHeHGayXhnCVZ0+EmqA=="></script>
<script defer src=/briztal.github.io/lib/katex/auto-render.min.e9b2833d28623d18c071d78ef13e9c79d695122d296af3dbcee7bf1bf6518b0565bab59939267fbc8f5faf696193c20f5caef3e7501969cfb306f6738032730d.js integrity="sha512-6bKDPShiPRjAcdeO8T6cedaVEi0pavPbzue/G/ZRiwVlurWZOSZ/vI9fr2lhk8IPXK7z51AZac+zBvZzgDJzDQ==" onload=renderMathInElement(document.body)></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/briztal.github.io class="text-base font-medium text-gray-500 hover:text-gray-900"></a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=briztal.github.io/projects/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title="Personal Projects">Projects</p></a><a href=briztal.github.io/about/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title="About me">About</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=briztal.github.io/projects/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title="Personal Projects">Projects</p></a></li><li class=mt-1><a href=briztal.github.io/about/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title="About me">About</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Memory Managers : Introduction.</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2021-09-17T00:00:00+00:00>17 September 2021</time></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='return window.open("briztal.github.io/categories/kernel/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Kernel</span></span></span>
<span style=margin-top:.5rem class=mr-2 onclick='return window.open("briztal.github.io/categories/memory-management/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Memory Management</span></span></span>
<span style=margin-top:.5rem class=mr-2 onclick='return window.open("briztal.github.io/categories/c/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">C</span></span></span>
<span style=margin-top:.5rem class=mr-2 onclick='return window.open("briztal.github.io/categories/operating-systems/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Operating Systems</span></span></span></div></div><div class="flex author"><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li><li><a href=#the-memory-bottleneck>The memory bottleneck</a></li><li><a href=#cache>Cache</a></li><li><a href=#page>Page</a></li><li><a href=#access-time>Access Time</a></li><li><a href=#system-constraints--numa>System constraints : NUMA</a></li><li><a href=#fundamental-orders>Fundamental orders</a></li><li><a href=#allocation-types>Allocation types</a></li><li><a href=#physical-memory-management----problem>Physical memory management, 🐔 & 🥚 problem</a></li><li><a href=#crossing-accesses>Crossing accesses</a></li><li><a href=#impact-on-the-memory-manager>Impact on the memory manager</a></li><li><a href=#impact-of-fundamental-orders-on-the-allocator>Impact of fundamental orders on the allocator</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li><li><a href=#the-memory-bottleneck>The memory bottleneck</a></li><li><a href=#cache>Cache</a></li><li><a href=#page>Page</a></li><li><a href=#access-time>Access Time</a></li><li><a href=#system-constraints--numa>System constraints : NUMA</a></li><li><a href=#fundamental-orders>Fundamental orders</a></li><li><a href=#allocation-types>Allocation types</a></li><li><a href=#physical-memory-management----problem>Physical memory management, 🐔 & 🥚 problem</a></li><li><a href=#crossing-accesses>Crossing accesses</a></li><li><a href=#impact-on-the-memory-manager>Impact on the memory manager</a></li><li><a href=#impact-of-fundamental-orders-on-the-allocator>Impact of fundamental orders on the allocator</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></details><script></script></div></div><div class="min-w-0 min-h-0 max-w-fit"><details style=margin-left:0 class="mt-2 mb-5 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5" open><summary class="py-1 text-lg font-semibold cursor-pointer bg-primary-200 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-primary-800 dark:text-neutral-100">Memory Management - This article is part of a series.</summary></details><div class="article-content max-w-prose mb-20"><p>Since this series of articles discuss memory, let&rsquo;s first define the concept of order of magnitude, which will be used as a more relevant metric than size to differentiate memory blocks.</p><p>$$
size = 2^{order}
$$</p><p>An order increment multiplies the size by 2.</p><h3 class="relative group">Introduction<div id=introduction class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#introduction aria-label=Anchor>#</a></span></h3><p>Memory is one of the most important resources of any running program, but is perhaps also one of the least correctly understood by programmers.</p><p>In most modern languages, an effort is made to take memory management out of the programmer’s hands.</p><p>Even in low level languages such as C or Rust, memory management, though being accessible to the programmer, is confined to the use of malloc/free-ish primitives, implemented in the language&rsquo;s standard library (ex : glibc).</p><p>The underlying memory managers and their implementations are meant to be invisible to the user, which may explain why so many developers are so unfamiliar with the different memory management techniques, and their associated costs, trade-offs, and efficiencies.</p><p>This series of article will take the opposite direction, and provide a simplified overview of different memory management techniques, their objectives, trade-offs, and explore how they interact with each other.</p><p>In this, we will cover the basics needed to properly understand memory managers, their design and performance.</p><p>The theory and designs that I will introduce in this article are based on my study of different kernels (linux being on the list), and on my own implementations and trials.</p><figure><img class="my-0 rounded-md" src=/briztal.github.io/images/memory_management/floppy.webp alt><figcaption>Image credits : Photo by pipp from FreeImages</figcaption></figure><h3 class="relative group">The memory bottleneck<div id=the-memory-bottleneck class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#the-memory-bottleneck aria-label=Anchor>#</a></span></h3><p>As software developers we tend to view memory as an uniform resource, with a constant and negligible access time.</p><p>I once asked a group of (computer science) students which type of instructions takes the longest time to complete among :</p><ul><li><strong>memory accesses</strong> (read / write).</li><li><strong>computational operations</strong> (int / float sum / diff / div).</li><li><strong>control flow operations</strong> (conditional (or not) jumps.</li></ul><p>They all chose computational operations, which is not surprising given what we are taught at school, and also considering the fact that in a program, memory accesses are simple enough to write (if not just transparent to the programmer) but computational and control flow operations are what most of the code will be about.</p><p>However, this is also incorrect in most cases.</p><p>Memory is the major bottleneck of modern computer micro architectures, and has been so since CPU cycle time and memory access time diverged, back in the 90s.</p><h3 class="relative group">Cache<div id=cache class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#cache aria-label=Anchor>#</a></span></h3><p>To mitigate this memory access bottleneck, modern CPU feature a transparent multi-level cache system.</p><p>Cache levels store and exchange contiguous memory blocks called cache lines.<br>Cache lines have a constant size and are aligned on this size.<br>The cache line is the smallest granule a cache can request memory on, and as a result, is the minumal granule at which all operations are executed from the external memory&rsquo;s standpoint.</p><p>Hence, on a CPU with empty caches :</p><ul><li>a memory <strong>read</strong> will cause a read of the <strong>entire cache line</strong> from memory to the cache system.</li><li>a memory <strong>write</strong> will cause a read plus at some point a write of the <strong>entire cache line</strong> to the memory system.</li><li>any operation <strong>requiring exclusivity</strong> on a memory location, like an atomic operation, will require the exclusive ownership of the <strong>whole cache line</strong> by the CPU&rsquo;s cache</li></ul><p>Additional details :</p><ul><li><a href="https://developers.redhat.com/blog/2016/03/01/reducing-memory-access-times-with-caches?source=post_page-----4f2acc9d5e28---------------------------------------#" target=_blank>Reducing Memory Access Times with Caches | Red Hat Developer</a></li><li><a href="https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>How L1 and L2 CPU Caches Work, and Why They&rsquo;re an Essential Part of Modern Chips | ExtremeTech</a></li></ul><h3 class="relative group">Page<div id=page class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#page aria-label=Anchor>#</a></span></h3><p>Modern systems are equipped with an MMU (Memory Management Unit) that provides, among others uses, memory access protection and virtualization capabilities.</p><p>In such systems, two different address spaces are to consider :</p><ul><li><strong>virtual address space</strong> : the address space accessed by programs (processes or kernel). Appart from the very early stages of boot nearly all code is using virtual address space.</li><li><strong>physical address space</strong> : the address space in which hardware devices are accessible at determined addresses, this includes DRAM, peripherals like UART, USB, ETHERNET, Bus interfaces like PCIE, etc…</li></ul><p>The relation between virtual and physical address relies on two concepts :</p><ul><li>the partition of both virtual and physical address spaces in blocks of constant sizes called pages (typical smallest size of 4KiB), aligned on their size. Virtual pages are called pages, physical pages are sometimes referred to as <em>frames</em>.</li><li>the definition by software (using a format defined by the hardware) of a set of translation rules, that associate at most one physical page to each virtual page, called a page-tree or page-table. The MMU uses this informatuon to translate a given virtual address into a physical address.</li></ul><p>The minimal granule at which translations can be decided is called the <strong>page order</strong> \((log2(page size))\) and is a hardware constant.</p><p>Though, the operating system may require, for its own reasons, to work on a larger base block.</p><ul><li><a href="https://www.enterprisestorageforum.com/hardware/paging-and-segmentation/?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>Paging and Segmentation | Enterprise Storage Forum</a></li><li><a href=https://developer.arm.com/documentation/den0013/d/The-Memory-Management-Unit/The-Translation-Lookaside-Buffer target=_blank>The Translation Lookaside Buffer (TLB) | Arm Developer</a></li></ul><h3 class="relative group">Access Time<div id=access-time class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#access-time aria-label=Anchor>#</a></span></h3><p>To estimate the time of a memory access, it is necessary to estimate the access time for all cache levels. And to estimate the average access time in a program, it is necessary to know the size of all cache levels and have some notions of each of the cache’s replacement policies, to be able to guess at which level the access might hit.</p><p>As such, this estimation is highly unreliable, a better estimation can be made by profiling the execution of the code or by using tools like cachegrind that simulate a cache hierarchy. Though still not exact, these can help the developer in making its software design choice and help evaluate the chosen development paradigms.</p><p>To illustrate how wide the differences in memory access times are between cache levels, let me provide indicative values for their access time in CPU cycles and typical size. These numbers are not meant to be taken literally, but rather, serve to show orders of magnitude.</p><div style=text-align:center>Registers : ~ 256B, ~1 cycle.<p>L1 cache : ~ 64KiB, ~ 4 cycles.</p><p>L2 cache : ~ 512KiB, ~ 20 cycles.</p><p>L3 cache : ~ 4MiB, ~ 100 cycles.</p><p>RAM : ~ 8GiB, ~ 200 cycles.</p></div><p>The following thread provides a more detailed comparison to a real CPU benchmark :</p><ul><li><a href="https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>Approximate cost to access various caches and main memory | Stack Overflow</a></li></ul><p>With this in mind, in order to make a program as efficient as possible, the two fundamental rules will be :</p><ul><li>To reduce as much as possible the amount of memory accesses.</li><li>If possible, increase spatial and temporal locality, i.e. to generate accesses at memory locations close to previous ones and not long after their use.</li></ul><h3 class="relative group">System constraints : NUMA<div id=system-constraints--numa class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#system-constraints--numa aria-label=Anchor>#</a></span></h3><p>NUMA (Non Uniform Memory Access) is a qualifier for a system where the physical memory access latency for a same address depends on the core the access originates from.</p><p>For example, in such systems, there may be multiple primary memory banks, located at different places in the motherboard, and multiple cores, also located at different places.</p><p>To simplify the management of these systems, we can conceptually group memory banks and cores in sets that we will call node (linuxian terminology), the node of a core and the node of a memory bank being the only factors taken into account when considering the latency of the core/bank access.</p><p>In all this series, we will place ourselves (and our allocators) in a NUMA system.<br>ie: a system with :</p><ul><li>One or more cores, i.e. processing elements, cpus…</li><li>One or more blocks of primary memory, i.e. primary memory that is provided as-it in the system (eg : DRAM), mapped in kernel address space and accessible by all cores of the system, but with a latency that may depend on the core (see <em>node</em> below).</li><li>One or more nodes.</li></ul><p>In this system, the first objectives of our memory manager is to :</p><ul><li>Reference primary memory blocks of each node.</li><li>Provide a primary memory allocation / free interface to each core.</li><li>Ensure that memory allocated to a CPU is as close as possible to this CPU.</li></ul><p>Additional details on NUMA :</p><ul><li><a href="https://www.kernel.org/doc/html/v5.0/vm/numa.html?source=post%5c_page-----4f2acc9d5e28---------------------------------------" target=_blank>What is NUMA ? | The Linux Kernel documentation</a></li><li><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>Non-uniform memory access | Wikipedia</a></li><li><a href="https://linuxhint.com/understanding_numa_architecture/?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>Understanding NUMA Architecture | LinuxHint</a></li></ul><h3 class="relative group">Fundamental orders<div id=fundamental-orders class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fundamental-orders aria-label=Anchor>#</a></span></h3><p>Here are some orders to keep in mind when discussing memory management :</p><ul><li>Byte : order 0, constant.</li><li>Pointer : order ~ 2 or 3 (= 4B or 8B), depends on the size of the virtual address space.</li><li>Cache line : order ~ 8 (= 64B), depends on the cache management system.</li><li>Page : order ~ 12 (= 4KiB), depends on the granularity of the page-table.</li><li>Primary memory block : order ~20 to 30 or more (1MiB -> 1GiB or more).</li></ul><figure><img class="my-0 rounded-md" src=/briztal.github.io/images/memory_management/page_order.webp alt="really cool diagram that I made"><figcaption>Visual representation of the fundamental orders.</figcaption></figure><h3 class="relative group">Allocation types<div id=allocation-types class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#allocation-types aria-label=Anchor>#</a></span></h3><p>With those orders in mind, let&rsquo;s consider the different allocation types, to help us classify allocators and the objectives :</p><ul><li><strong>small blocks (&lt; cache_line_size)</strong> : frequent allocation, used for a huge part of object allocations (average size of malloced structures = 60 bytes), must be fast, small blocks must respect the fundamental alignment.</li><li><strong>intermediate blocks ( &lt; page_size)</strong> : least frequent allocation, used for larger structs, may not be fast. Intermediate blocks must respect the fundamental alignment.</li><li><strong>page ( = page_size)</strong> : used by the kernel to populate page-tables, usage by secondary allocators as superblocks, must be very fast. Pages must be aligned on the page order.</li><li><strong>page blocks</strong> : contiguous page blocks, used by secondary allocators, less frequent. Page blocks must be aligned on the page order.</li></ul><h3 class="relative group">Physical memory management, 🐔 & 🥚 problem<div id=physical-memory-management----problem class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#physical-memory-management----problem aria-label=Anchor>#</a></span></h3><p>Physical memory management is a difficult problem, because it cannot require the use of any other allocator, as it is <strong>THE</strong> first allocator, the one managing physical memory, which is provided as-it.</p><p>It cannot use per-page or per-page block metadata inside those pages (or page blocks, blocks), but it split the block of physical memory that it manages into two :</p><ul><li>allocatable pages.</li><li>metadata for the allocatable pages.</li></ul><p>Let&rsquo;s note two things first :</p><ul><li>Allocating a page is a subproblem of allocating a page block.</li><li>An allocator able to provide page blocks can be used as a memory source for memory allocators that allocate smaller blocks.</li></ul><p>Hence, we can define two types of memory allocators :</p><ul><li><strong>Primary allocators</strong> who manage primary memory blocks, and that allocate page blocks in those.</li><li><strong>Secondary allocators</strong> who divide page blocks provided by primary allocators into smaller blocks that they allocate to their users.</li></ul><p>The anatomy of a primary allocator, (the buddy), and of several secondary allocators will be detailed in the next chapter.</p><h3 class="relative group">Crossing accesses<div id=crossing-accesses class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#crossing-accesses aria-label=Anchor>#</a></span></h3><p>I stated before that the base granule for memory operations is the cache line.</p><p>Now, let’s look the following C code, assume that compiler optimisations and registers do not exist, and try to predict what accesses will be generated by the assembly produced by the compiler :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>  <span class=cm>/* Part 1. */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint64_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>  <span class=cm>/* Part 2. */</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>t</span><span class=p>[</span><span class=mi>16</span><span class=p>]</span> <span class=nf>__attribute__</span><span class=p>((</span><span class=nf>aligned</span><span class=p>(</span><span class=mi>8</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>t</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In part 1, the compiler will generate two memory writes instructions targetting the stack (no registers) for <code>i</code> and <code>j</code> : <code>i</code> will be stored using a 1-byte write, and <code>j</code> will be stored with an 8-bytes write.</p><p>In part 2, we define char array of 16 bytes on the stack, whose first element’s address is aligned on 8 bytes (__attribute__(…)). Let its address (dynamically determined in a real world example since the stack is used to store local variables) be 56 for our exmple. To perform the write, the compiler to generate a 8-bytes write at addresses [57, 64].</p><p>For the record, it is explicitly mentioned in all the C language standards that this type of pointer casts has an <strong>undefined behavior</strong>.</p><p>Now if we suppose that the cache line size of our system is 64 Bytes, we just generated a memory write that spans across two cache lines : the first part from 57 to 63 (on cache line ranging from addresses 0–63), the second on 64 (on cache line ranging from addresses 64–127), this type of access being infamously known as an <strong>unaligned access</strong>.</p><p>Unaligned accesses may carry a severe penalty and are generally something to avoid generating, as it may lead to undefined behaviors. The example we described was fairly simple, and the answer “ yeah I don’t care generate two accesses instead of one ”, could fly. But supporting this in HW may make CPU designers unhappy.</p><p>But if an access can cross cache lines, it can also cross a page boundary and can involve pages of virtual memory, which could be mapped with different access privileges and cacheability (another attribute held by the page table).</p><p>What should the CPU do in this case ? Fault ? Generate two accesses on the different cache lines with different attributes ? CPU designers just went from &lsquo;unhappy&rsquo; to &lsquo;complaining&rsquo;.</p><p>Worse case : one of the two virtual page could be mapped, and the other could be non-mapped.</p><p>What should the CPU do in this case ? Perform none of the accesses ? Perform the valid part of the access, and not the other ? CPU designers just transitioned to &lsquo;angry&rsquo;.</p><p>Worse, the access could be an atomic instruction that requires the exclusivity on one cache line, which is a hell of a heavy work for a CPU.</p><p>What should the CPU do in this case ? Fault ? Require the exclusivity on two cache lines and split the access ? CPU designers just transitioned to &rsquo;trying to find out where you live&rsquo;.</p><p>Some architectures like the old ARM processors (ARMV4T) did not support unaligned accesses, others tolerated it and optionally trapped them, or profiled them so they could be reported to the respectful developer.</p><p>The safest certainty we have is that they should be avoided if at all possible. As a matter of fact, the C compiler never generates any unaligned memory access.</p><p>Except when it does.</p><p>I once had an unpleasant experience dealing with a version of the C standard library that had some functions that generated such accesses. For the record, those functions were memcpy and memset, and they generated unaligned accesses by uncarefully extending the read / copy / write granularity without checking the alignment of source/dest addresses.</p><p>Additional reading :</p><ul><li><a href="https://blog.quarkslab.com/unaligned-accesses-in-cc-what-why-and-solutions-to-do-it-properly.html?source=post_page-----4f2acc9d5e28---------------------------------------" target=_blank>Unaligned accesses in C/C++: what, why and solutions to do it properly | Quarkslab&rsquo;s blog</a></li><li><a href=https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt target=_blank>Unaligned Memory Accesses | Linux Kernel Documentation</a></li></ul><h3 class="relative group">Impact on the memory manager<div id=impact-on-the-memory-manager class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#impact-on-the-memory-manager aria-label=Anchor>#</a></span></h3><p>The key takeaway to be remembered from the last paragraph is that <strong>unaligned access cause perf and power hits and therefore should be avoided</strong>.</p><p>This means that any object legitimately instantiated in memory should not generate unaligned accesses.</p><p>For example, an instance of the following struct allocated with our memory allocator</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>s</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>  <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>should not generate any unaligned accesses when accessing any of its fields.</p><p>The C compiler (unless manually instructed to do so by the snarky developper) will add padding to this struct the following way :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=n>s</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span>  <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>pad</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>But for every field to be accessed without unaligned accesses, when providing a memory block B, an allocator must ensure that B&rsquo;s start address meets alignment requirements for any primitive type that can be placed in an aligned manner in B.</p><p>Eg " in 64 bits systems, a block of size 1 can be placed everywhere in memory, a block of size 2 start at an address that is a multiple of 2, a block of size 4 must start at an address that is a multiple of 4, a block of size 8 or more must start at an address that is a multiple of 8._</p><p>If you wonder, the documentation of the malloc C function, states a similar constraint :</p><blockquote><p>“If allocation succeeds, returns a pointer that is suitably aligned for any object type with fundamental alignment.”</p></blockquote><h3 class="relative group">Impact of fundamental orders on the allocator<div id=impact-of-fundamental-orders-on-the-allocator class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#impact-of-fundamental-orders-on-the-allocator aria-label=Anchor>#</a></span></h3><p>The different orders we defined to characterise our memory system may vary among different systems, their variations having an impact on the memory manager and the amount of allocated memory for a same program:</p><p><strong>Byte order</strong> : 1, invariant.</p><p><strong>Pointer order</strong> : has a direct impact on the amount of memory used by a program.</p><p>Indeed, when reading the source of large C projects, linux being a good example, it is easy to notice that most data structures are packed with pointers. A variation of the pointer size will cause a similar variation on the size of those structs.</p><p><strong>Cache line order</strong> : has an impact on the secondary memory manager.</p><p>Indeed, the cache line is the base granule on which synchronization instructions operate on modern CPUs : when you execute an atomic operation, the core’s memory system requires the exclusivity on the cache line, then executes your operation, then confirms that the exclusivity was held during the whole operation.</p><p>For this reason, it is important that memory allocated to an end-user that may use synchronization instructions on it, is allocated on the granule of a cache line (and aligned on the cache line size). This is needed to avoid a situation where two users could, for example, attempt to lock two different spinlocks, present in two different structures each one of size cache_line_size / 2, but allocated on the same cache line by the memory manager. In this case, when trying to acquire the spinlock and requiring the exclusivity of the cache line. Each of the two users will be blocking the other’s ability to acquire the other spinlock, thus creating additional, unnecessary and expensive memory access conflicts.</p><p><strong>Page size order</strong> : has a possible impact on internal fragmentation of secondary allocators, and on efficiency of secondary allocators.</p><p>Secondary allocators, as stated before, manage superblocks provided by primary allocators, and use those to allocate smaller blocks. Increasing the page order will increase the minimal superblock size, and so, the amount of primary memory allocated at each superblock allocation.</p><p>Now let’s say that a secondary allocator is constructed and receives a single allocation request for 64 Bytes of memory. A superblock will have to be allocated, and will be used to provide the 64 Bytes.</p><p>Now if no more memory is required from this secondary allocator, the whole superblock will still be allocated and not usable by other software. This could cause a large external fragmentation.</p><p>Now, increasing the superblock size will also decrease the rate at which superblocks will be allocated, which will slightly increase the allocator’s efficiency.</p><figure><img class="my-0 rounded-md" src=/briztal.github.io/images/memory_management/size_diff.webp alt><figcaption>Visual representation of size differences between fundamental orders.</figcaption></figure><h3 class="relative group">Conclusion<div id=conclusion class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#conclusion aria-label=Anchor>#</a></span></h3><p>This chapter will have stated what I believe are the most basic things to keep in mind when speaking of memory managers.</p><p>In the next chapter, we will be focusing on the structure of the primary and secondary memory managers.</p></div><details style=margin-left:0 class="mt-2 mb-5 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5"><summary class="py-1 text-lg font-semibold cursor-pointer bg-primary-200 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-primary-800 dark:text-neutral-100">Memory Management - This article is part of a series.</summary></details></div><script>var oid="views_projects/memory_management/mm_0_into.md",oid_likes="likes_projects/memory_management/mm_0_into.md"</script><script type=text/javascript src=/briztal.github.io/js/page.min.b06a29d42a4ed16787978e2eee1e8c797b7698db2bc14ccee78f5c80ac566fc996190a73ad80a5e987558474b20b96fa38f7d85b405f165ff72b7b163c5ad11b.js integrity="sha512-sGop1CpO0WeHl44u7h6MeXt2mNsrwUzO549cgKxWb8mWGQpzrYCl6YdVhHSyC5b6OPfYW0BfFl/3K3sWPFrRGw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span></span><span><a class="flex text-right group ml-3" href=briztal.github.io/projects/memory_management/mm_1/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Memory Manager : Primary allocators.</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2021-09-19T00:00:00+00:00>19 September 2021</time></span></span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2025</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a></p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/briztal.github.io/js/process.min.62060bb247f4de2b6dde45903668fefb68d792f365587605177b1227c0cf43588701edaca0cb40e2c8e2789bd5ce67c1d2a215b9fb258c3496a7cd25e7cb5fdf.js integrity="sha512-YgYLskf03itt3kWQNmj++2jXkvNlWHYFF3sSJ8DPQ1iHAe2soMtA4sjieJvVzmfB0qIVufsljDSWp80l58tf3w=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=briztal.github.io style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>